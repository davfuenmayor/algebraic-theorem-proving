(**************************************************************)
(*           Copyright (c) 2024 David Fuenmayor               *)
(*       MIT License (see LICENSE file for details)           *)
(**************************************************************)
theory F4_orderA
imports F4
begin

fun leqA::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> bool"  (infix "\<sqsubseteq>" 51) where
  "a \<sqsubseteq> _ = \<top>" |
  "_ \<sqsubseteq> b = \<top>" |
  "0 \<sqsubseteq> 0 = \<top>" |
  "1 \<sqsubseteq> 1 = \<top>" |
  "_ \<sqsubseteq> _ = \<bottom>"

abbreviation(input) geqA::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> bool" (infix "\<sqsupseteq>" 51)
  where "x \<sqsupseteq> y \<equiv> y \<sqsubseteq> x"


(*Checks*)
lemma reflA: "x \<sqsubseteq> x" by (smt (verit) leqA.elims leqA.simps)
lemma transA: "x \<sqsubseteq> y \<and> y \<sqsubseteq> z \<longrightarrow> x \<sqsubseteq> z" by (smt (verit) leqA.simps leqA.elims)
lemma antisymA: "x \<sqsubseteq> y \<and> y \<sqsubseteq> x \<longrightarrow> x = y" by (smt (verit) leqA.simps leqA.elims)

(*Note that the order is not linear (0 and 1 are incomparable):*)
lemma "0 \<sqsubseteq> 1" nitpick oops (*countermodel*)
lemma "1 \<sqsubseteq> 0" nitpick oops (*countermodel*)

(*Let's introduce the A-lattice operations: meet and join*)
fun MeetA::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> F\<^sub>4" (infixl "\<^bold>\<sqinter>" 56) where (* A-lattice meet *)
  "0 \<^bold>\<sqinter> 0 = 0" |
  "0 \<^bold>\<sqinter> 1 = a" |
  "0 \<^bold>\<sqinter> a = a" |
  "0 \<^bold>\<sqinter> b = 0" |
  "1 \<^bold>\<sqinter> 0 = a" |
  "1 \<^bold>\<sqinter> 1 = 1" |
  "1 \<^bold>\<sqinter> a = a" |
  "1 \<^bold>\<sqinter> b = 1" |
  "a \<^bold>\<sqinter> 0 = a" |
  "a \<^bold>\<sqinter> 1 = a" |
  "a \<^bold>\<sqinter> a = a" |
  "a \<^bold>\<sqinter> b = a" |
  "b \<^bold>\<sqinter> 0 = 0" |
  "b \<^bold>\<sqinter> 1 = 1" |
  "b \<^bold>\<sqinter> a = a" |
  "b \<^bold>\<sqinter> b = b"

fun JoinA::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> F\<^sub>4" (infixl "\<^bold>\<squnion>" 55) where (* A-lattice join *)
  "0 \<^bold>\<squnion> 0 = 0" |
  "0 \<^bold>\<squnion> 1 = b" |
  "0 \<^bold>\<squnion> a = 0" |
  "0 \<^bold>\<squnion> b = b" |
  "1 \<^bold>\<squnion> 0 = b" |
  "1 \<^bold>\<squnion> 1 = 1" |
  "1 \<^bold>\<squnion> a = 1" |
  "1 \<^bold>\<squnion> b = b" |
  "a \<^bold>\<squnion> 0 = 0" |
  "a \<^bold>\<squnion> 1 = 1" |
  "a \<^bold>\<squnion> a = a" |
  "a \<^bold>\<squnion> b = b" |
  "b \<^bold>\<squnion> 0 = b" |
  "b \<^bold>\<squnion> 1 = b" |
  "b \<^bold>\<squnion> a = b" |
  "b \<^bold>\<squnion> b = b" 

lemma latticeA_distr1: "(x \<^bold>\<sqinter> (y \<^bold>\<squnion> z)) = ((x \<^bold>\<sqinter> y) \<^bold>\<squnion> (x \<^bold>\<sqinter> z))"
  by (smt (z3) MeetA.simps JoinA.simps F\<^sub>4.exhaust)
lemma latticeA_distr2: "(x \<^bold>\<squnion> (y \<^bold>\<sqinter> z)) = ((x \<^bold>\<squnion> y) \<^bold>\<sqinter> (x \<^bold>\<squnion> z))"
  by (smt (z3) MeetA.simps JoinA.simps F\<^sub>4.exhaust)


subsection \<open>Residuation (wrt. A-lattice)\<close>

(*First, observe that the following don't hold for inequalities: *)
lemma "((x + y) \<sqsubseteq> z) \<longleftrightarrow> (x \<sqsubseteq> (z - y))" nitpick oops (*countermodel: addition can 'overflow' (ring is finite)*)
lemma "y \<noteq> 0 \<Longrightarrow> ((x * y) \<sqsubseteq> z) \<longleftrightarrow> (x \<sqsubseteq> (z / y))" nitpick oops (*countermodel*)


abbreviation residualA ("RESID\<^sup>A") 
  where "RESID\<^sup>A f g \<equiv> \<forall>x y z. (f z x \<sqsubseteq> y) \<longleftrightarrow> (x \<sqsubseteq> g z y)"

(*In fact, left/right residuals, when they exist, are unique*)
lemma "RESID\<^sup>A f g\<^sub>1 \<and> RESID\<^sup>A f g\<^sub>2 \<longrightarrow> g\<^sub>1 = g\<^sub>2"
  using antisymA reflA (*by metis*) sorry (*TODO: metis reconstruction fails *)
lemma "RESID\<^sup>A f\<^sub>1 g \<and> RESID\<^sup>A f\<^sub>2 g \<longrightarrow> f\<^sub>1 = f\<^sub>2" 
  using antisymA reflA (*by metis*) sorry (*TODO: metis reconstruction fails *)

(*As it happens, there is no right residual to '*' and no left residual to '+' either: *)
lemma "RESID\<^sup>A (*) g" nitpick[satisfy, expect=none] oops
lemma "RESID\<^sup>A f (+)" nitpick[satisfy, expect=none] oops

(*But there is (at least) a residuated pair \<langle>f,g\<rangle> to be found... *)
lemma "RESID\<^sup>A f g" nitpick[satisfy] oops

(*In fact, meet-A resp. join-A have right resp left residuals, and we can use nitpick to find them: *)
lemma "RESID\<^sup>A (\<^bold>\<sqinter>) g" nitpick[satisfy] oops
lemma "RESID\<^sup>A f (\<^bold>\<squnion>)" nitpick[satisfy] oops

(*We call meet's right residual: 'implication'. Based upon the truth table generated by nitpick we define:*)
fun ImplicationA::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> F\<^sub>4" (infixr "\<^bold>\<Rightarrow>" 54) where
  "0 \<^bold>\<Rightarrow> 0 = b" | 
  "0 \<^bold>\<Rightarrow> 1 = 1" |
  "0 \<^bold>\<Rightarrow> a = 1" |
  "0 \<^bold>\<Rightarrow> b = b" |
  "1 \<^bold>\<Rightarrow> 0 = 0" |
  "1 \<^bold>\<Rightarrow> 1 = b" |
  "1 \<^bold>\<Rightarrow> a = 0" |
  "1 \<^bold>\<Rightarrow> b = b" |
  "a \<^bold>\<Rightarrow> 0 = b" |
  "a \<^bold>\<Rightarrow> 1 = b" |
  "a \<^bold>\<Rightarrow> a = b" |
  "a \<^bold>\<Rightarrow> b = b" |
  "b \<^bold>\<Rightarrow> 0 = 0" |
  "b \<^bold>\<Rightarrow> 1 = 1" |
  "b \<^bold>\<Rightarrow> a = a" |
  "b \<^bold>\<Rightarrow> b = b"

(*We call joins's left residual: 'dual-implication'. Based upon the truth table generated by nitpick we define:*)
fun DualImplicationA::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> F\<^sub>4" (infixl "\<^bold>\<hookrightarrow>" 54) where
  "0 \<^bold>\<hookrightarrow> 0 = a" |
  "0 \<^bold>\<hookrightarrow> 1 = 1" |
  "0 \<^bold>\<hookrightarrow> a = a" |
  "0 \<^bold>\<hookrightarrow> b = 1" |
  "1 \<^bold>\<hookrightarrow> 0 = 0" |
  "1 \<^bold>\<hookrightarrow> 1 = a" |
  "1 \<^bold>\<hookrightarrow> a = a" |
  "1 \<^bold>\<hookrightarrow> b = 0" |
  "a \<^bold>\<hookrightarrow> 0 = 0" |
  "a \<^bold>\<hookrightarrow> 1 = 1" |
  "a \<^bold>\<hookrightarrow> a = a" |
  "a \<^bold>\<hookrightarrow> b = b" |
  "b \<^bold>\<hookrightarrow> 0 = a" |
  "b \<^bold>\<hookrightarrow> 1 = a" |
  "b \<^bold>\<hookrightarrow> a = a" |
  "b \<^bold>\<hookrightarrow> b = a"

lemma residA_law1: "RESID\<^sup>A (\<^bold>\<sqinter>) (\<^bold>\<Rightarrow>)" by (smt (z3) ImplicationA.simps MeetA.simps leqA.simps F\<^sub>4.exhaust)
lemma residA_law2: "RESID\<^sup>A (\<^bold>\<hookrightarrow>) (\<^bold>\<squnion>)" by (smt (z3) DualImplicationA.simps JoinA.simps leqA.simps F\<^sub>4.exhaust)

(*More explicitly, we have: *)
lemma "(z \<^bold>\<sqinter>  x \<sqsubseteq> y) \<longleftrightarrow> (x \<sqsubseteq> z \<^bold>\<Rightarrow> y)" by (simp add: residA_law1)
lemma "(z \<^bold>\<hookrightarrow> x \<sqsubseteq> y) \<longleftrightarrow> (x \<sqsubseteq> z \<^bold>\<squnion> y)" by (simp add: residA_law2)

(*However, an analog result for equalities does not hold:*)
lemma "(z \<^bold>\<sqinter> x = y) \<longleftrightarrow> (x = z \<^bold>\<Rightarrow> y)" nitpick oops (*countermodel*)
lemma "(z \<^bold>\<hookrightarrow> x = y) \<longleftrightarrow> (x = z \<^bold>\<squnion> y)" nitpick oops (*countermodel*)

(*Let's add for writing convenience: *)
abbreviation(input) ImplA_rev (infixl "\<^bold>\<Leftarrow>" 54) 
  where "x \<^bold>\<Leftarrow> y \<equiv> y \<^bold>\<Rightarrow> x"
abbreviation(input) DImplA_rev (infixr "\<^bold>\<hookleftarrow>" 54) 
  where "x \<^bold>\<hookleftarrow> y \<equiv> y \<^bold>\<hookrightarrow> x" 

(*In fact the following holds: *)
lemma "(x \<^bold>\<Rightarrow> y = b) \<longleftrightarrow> (x \<sqsubseteq> y)"
  by (smt (z3) ImplicationA.simps MultiplicativeInverse.cases leqA.simps)
lemma "(x \<^bold>\<hookleftarrow> y = a) \<longleftrightarrow> (x \<sqsubseteq> y)"
  by (smt (z3) DualImplicationA.simps MultiplicativeInverse.cases leqA.simps)

(*While the following does not hold: *)
lemma "(x \<^bold>\<Rightarrow> y \<sqsupseteq> 1) \<longleftrightarrow> (x \<sqsubseteq> y)" nitpick oops (*counterexample*)
lemma "(x \<^bold>\<Rightarrow> y \<sqsupseteq> 0) \<longleftrightarrow> (x \<sqsubseteq> y)" nitpick oops (*counterexample*)
lemma "(x \<^bold>\<hookleftarrow> y \<sqsubseteq> 0) \<longleftrightarrow> (x \<sqsubseteq> y)" nitpick oops (*counterexample*)
lemma "(x \<^bold>\<hookleftarrow> y \<sqsubseteq> 1) \<longleftrightarrow> (x \<sqsubseteq> y)" nitpick oops (*counterexample*)

(*The previous results justify introducing the following convenient definitions: *)
abbreviation(input) Top ("\<^bold>\<top>\<^sup>A")    where "\<^bold>\<top>\<^sup>A \<equiv> b"
abbreviation(input) Bottom ("\<^bold>\<bottom>\<^sup>A") where "\<^bold>\<bottom>\<^sup>A \<equiv> a"

(*Finally, let's find the polynomial representations for the operations discussed above: *)

(*Uses Nitpick to find polynomial coeficients and to compute the table*)
lemma "(\<^bold>\<sqinter>) = poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" 
(*  nitpick[satisfy, eval="poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"] *) oops
lemma "(\<^bold>\<squnion>) = poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" 
(*  nitpick[satisfy, eval="poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"] *) oops
lemma "(\<^bold>\<Rightarrow>) = poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" 
(*  nitpick[satisfy, eval="poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"] *) oops
lemma "(\<^bold>\<hookrightarrow>) = poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" 
(*  nitpick[satisfy, eval="poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"] *) oops

(*Verifies polynomial representation*)
lemma MeetA_polydef:            "(x \<^bold>\<sqinter> y)  = (x\<^sup>2\<cdot>y\<^sup>2 + x\<^sup>2\<cdot>y + x\<^sup>2 + x\<cdot>y\<^sup>2 + b\<cdot>x + y\<^sup>2 + b\<cdot>y)" by (smt (z3) Addition.simps MeetA.simps Multiplication.simps F\<^sub>4.exhaust)
lemma JoinA_polydef:            "(x \<^bold>\<squnion> y)  = (x\<^sup>2\<cdot>y\<^sup>2 + x\<^sup>2\<cdot>y + x\<^sup>2 + x\<cdot>y\<^sup>2 + a\<cdot>x + y\<^sup>2 + a\<cdot>y)" by (smt (z3) Addition.simps JoinA.simps Multiplication.simps F\<^sub>4.exhaust)
lemma ImplicationA_polydef:     "(x \<^bold>\<Rightarrow> y) = (x\<^sup>2\<cdot>y\<^sup>2 + x\<^sup>2\<cdot>y + x\<^sup>2 + x\<cdot>y\<^sup>2 + a\<cdot>x + y\<^sup>2 + b\<cdot>y + b)" by (smt (z3) Addition.simps ImplicationA.simps Multiplication.simps F\<^sub>4.exhaust)
lemma DualImplicationA_polydef: "(x \<^bold>\<hookrightarrow> y) = (x\<^sup>2\<cdot>y\<^sup>2 + x\<^sup>2\<cdot>y + x\<^sup>2 + x\<cdot>y\<^sup>2 + b\<cdot>x + y\<^sup>2 + a\<cdot>y + a)" by (smt (z3) Addition.simps DualImplicationA.simps Multiplication.simps F\<^sub>4.exhaust)


named_theorems polydefs
declare MeetA_polydef[polydefs] JoinA_polydef[polydefs] 
        ImplicationA_polydef[polydefs] DualImplicationA_polydef[polydefs]

end