(**************************************************************)
(*           Copyright (c) 2024 David Fuenmayor               *)
(*       MIT License (see LICENSE file for details)           *)
(**************************************************************)
theory Z2_order
imports Z2
begin

section \<open>Ordering Z2\<close>

subsection \<open>Order Structure\<close>

fun leq::"Z\<^sub>2 \<Rightarrow> Z\<^sub>2 \<Rightarrow> bool"  (infix "\<le>" 51) where
  "0 \<le> _ = \<top>" |
  "_ \<le> 1 = \<top>" |
  "_ \<le> _ = \<bottom>"

abbreviation(input) geq::"Z\<^sub>2 \<Rightarrow> Z\<^sub>2 \<Rightarrow> bool" (infix "\<ge>" 51)
  where "x \<ge> y \<equiv> y \<le> x"

lemma "0 \<le> 1" by simp
lemma "1 \<le> 0" nitpick oops

lemma refl: "x \<le> x" using leq.elims(3) by blast
lemma trans: "x \<le> y \<and> y \<le> z \<longrightarrow> x \<le> z" by (metis leq.elims(2))
lemma antisym: "x \<le> y \<and> y \<le> x \<longrightarrow> x = y" by (metis leq.elims(2))
lemma linear: "x \<le> y \<or> y \<le> x" by (metis Z\<^sub>2.distinct(2) leq.elims(3))

(*Let's introduce the lattice operations: meet/min and join/max*)
fun Meet::"Z\<^sub>2 \<Rightarrow> Z\<^sub>2 \<Rightarrow> Z\<^sub>2" (infixl "\<^bold>\<and>" 56) where (*minimal (meet) of two values*)
  "0 \<^bold>\<and> 0 = 0" |
  "0 \<^bold>\<and> 1 = 0" |
  "1 \<^bold>\<and> 0 = 0" |
  "1 \<^bold>\<and> 1 = 1"

lemma Meet_mindef: "Meet x y = (if x \<le> y then x else y)" (*double check*)
  by (metis (full_types) Meet.simps(1) Meet.simps(2) Meet.simps(3) Meet.simps(4) Z\<^sub>2.exhaust leq.simps(1) leq.simps(3))

fun Join::"Z\<^sub>2 \<Rightarrow> Z\<^sub>2 \<Rightarrow> Z\<^sub>2" (infixl "\<^bold>\<or>" 55) where (*maximal (join) of two values*)
  "0 \<^bold>\<or> 0 = 0" |
  "0 \<^bold>\<or> 1 = 1" |
  "1 \<^bold>\<or> 0 = 1" |
  "1 \<^bold>\<or> 1 = 1"

lemma Join_maxdef: "Join x y = (if x \<le> y then y else x)" (*double check*)
  by (metis (full_types) Join.simps(1) Join.simps(2) Join.simps(3) Join.simps(4) Z\<^sub>2.exhaust leq.simps(1) leq.simps(3))

lemma lattice_distr1: "(x \<^bold>\<and> (y \<^bold>\<or> z)) = ((x \<^bold>\<and> y) \<^bold>\<or> (x \<^bold>\<and> z))" sorry (*TODO: reconstruction takes too long*)
  (* by (smt (z3) Join.elims Join.simps(3) Meet.simps(1) Meet.simps(2) Meet.simps(3) Meet.simps(4)) *)
lemma lattice_distr2: "(x \<^bold>\<or> (y \<^bold>\<and> z)) = ((x \<^bold>\<or> y) \<^bold>\<and> (x \<^bold>\<or> z))" sorry (*TODO: reconstruction takes too long*) 
  (* by (smt (z3) Join.elims Join.simps(1) Join.simps(2) Meet.elims Meet.simps(1) Meet.simps(4)) *)


subsection \<open>Residuation\<close>

(*Two unary operations f & g can be said to form a 'residuated pair'. This definition can be seamlessly
  extended to binary operations*)
abbreviation(input) "RESID f g \<equiv> \<forall>x y. (f x \<le> y) \<longleftrightarrow> (x \<le> g y)"
abbreviation(input) "RESID2 f g \<equiv> \<forall>z. RESID (f z) (g z)"

lemma "RESID2 f g = (\<forall>x y z. (f z x \<le> y) \<longleftrightarrow> (x \<le> g z y))" by blast

(*Meet resp. join have right resp left residuals (the usual suspects), and we can use nitpick to find them : *)
lemma "RESID2 (\<^bold>\<and>) g" nitpick[satisfy] oops
lemma "RESID2 f (\<^bold>\<or>)" nitpick[satisfy] oops

(*We call meet's right residual: 'implication'. Based upon the truth table generated by nitpick we define:*)
fun Implication::"Z\<^sub>2 \<Rightarrow> Z\<^sub>2 \<Rightarrow> Z\<^sub>2" (infixr "\<^bold>\<rightarrow>" 54) where
  "0 \<^bold>\<rightarrow> 0 = 1" |
  "0 \<^bold>\<rightarrow> 1 = 1" |
  "1 \<^bold>\<rightarrow> 0 = 0" |
  "1 \<^bold>\<rightarrow> 1 = 1"

(*We call joins's left residual: 'dual-implication'. Based upon the truth table generated by nitpick we define:*)
fun DualImplication::"Z\<^sub>2 \<Rightarrow> Z\<^sub>2 \<Rightarrow> Z\<^sub>2" (infixl "\<^bold>\<rightharpoonup>" 54) where
  "0 \<^bold>\<rightharpoonup> 0 = 0" |
  "0 \<^bold>\<rightharpoonup> 1 = 1" |
  "1 \<^bold>\<rightharpoonup> 0 = 0" |
  "1 \<^bold>\<rightharpoonup> 1 = 0"

lemma resid_law1: "RESID2 (\<^bold>\<and>) (\<^bold>\<rightarrow>)" sorry (*TODO: reconstruction takes too long*) 
  (* by (smt (z3) Implication.elims Meet.elims leq.elims(3)) *)
lemma resid_law2: "RESID2 (\<^bold>\<rightharpoonup>) (\<^bold>\<or>)" sorry (*TODO: reconstruction takes too long*)
  (* by (smt (z3) DualImplication.elims Join_maxdef leq.elims(3)) *)

(*More explicitly, we have: *)
lemma "(z \<^bold>\<and>  x \<le> y) \<longleftrightarrow> (x \<le> z \<^bold>\<rightarrow> y)" by (simp add: resid_law1)
lemma "(z \<^bold>\<rightharpoonup> x \<le> y) \<longleftrightarrow> (x \<le> z \<^bold>\<or> y)" by (simp add: resid_law2)

(*However, an analog result for equalities does not hold:*)
lemma "(z \<^bold>\<and> x = y) \<longleftrightarrow> (x = z \<^bold>\<rightarrow> y)" nitpick oops (*countermodel*)
lemma "(z \<^bold>\<rightharpoonup> x = y) \<longleftrightarrow> (x = z \<^bold>\<or> y)" nitpick oops (*countermodel*)

(*Let's add for writing convenience: *)
abbreviation(input) DualImplication_rev (infixr "\<^bold>\<leftharpoonup>" 54) 
  where "x \<^bold>\<leftharpoonup> y \<equiv> y \<^bold>\<rightharpoonup> x" 
abbreviation(input) Implication_rev (infixl "\<^bold>\<leftarrow>" 54) 
  where "x \<^bold>\<leftarrow> y \<equiv> y \<^bold>\<rightarrow> x"

(*In fact the following holds: *)
lemma "(x \<^bold>\<rightarrow> y = 1) \<longleftrightarrow> (x \<le> y)" sorry (*TODO: reconstruction takes too long*)
  (* by (smt (z3) Implication.elims Z\<^sub>2.distinct(2) leq.elims(1)) *)
lemma "(x \<^bold>\<leftharpoonup> y = 0) \<longleftrightarrow> (x \<le> y)" sorry (*TODO: reconstruction takes too long*)
  (* by (smt (verit, best) DualImplication.elims Z\<^sub>2.distinct(2) leq.elims(3) leq.simps(3)) *)

(*The previous results justify introducing the following convenient definitions: *)
abbreviation(input) Top ("\<^bold>\<top>")    where "\<^bold>\<top> \<equiv> 1"
abbreviation(input) Bottom ("\<^bold>\<bottom>") where "\<^bold>\<bottom> \<equiv> 0"


(*Finally, let's find the polynomial representations for the operations discussed above: *)

(*Uses Nitpick to find polynomial coeficients and to compute the table*)
lemma "(\<^bold>\<and>) = poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" nitpick[satisfy, eval="poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"] oops
lemma "(\<^bold>\<or>) = poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" nitpick[satisfy, eval="poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"] oops
lemma "(\<^bold>\<rightarrow>) = poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" nitpick[satisfy, eval="poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"] oops
lemma "(\<^bold>\<rightharpoonup>) = poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" nitpick[satisfy, eval="poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"] oops

(*Verifies polynomial representation*)
lemma Meet_polydef:            "(x \<^bold>\<and> y) =   x\<cdot>y" 
  by (smt (z3) Meet.elims Multiplication.elims)
lemma Join_polydef:            "(x \<^bold>\<or> y) =  (x\<cdot>y + x + y)" sorry (*TODO: reconstruction takes too long*)
  (* by (smt (verit, best) Addition.simps(1) Addition.simps(2) Addition.simps(3) Join.simps(1) Join.simps(2) Join.simps(3) Join.simps(4) Multiplication.elims) *)
lemma Implication_polydef:     "(x \<^bold>\<rightarrow> y) = (x\<cdot>y + x     + 1)" by (metis (full_types) Addition.simps(1) Addition.simps(2) Addition.simps(4) Implication.simps(1) Implication.simps(2) Implication.simps(3) Implication.simps(4) Meet.simps(1) Meet.simps(2) Meet.simps(3) Meet.simps(4) Meet_polydef Z\<^sub>2.exhaust)
lemma DualImplication_polydef: "(x \<^bold>\<rightharpoonup> y) = (x\<cdot>y     + y)" by (metis (full_types) Addition.simps(1) Addition.simps(2) Addition.simps(4) DualImplication.simps(1) DualImplication.simps(2) DualImplication.simps(3) DualImplication.simps(4) Meet.simps(1) Meet.simps(2) Meet.simps(3) Meet.simps(4) Meet_polydef Z\<^sub>2.exhaust)


subsection \<open>Negation\<close>

fun Negation::"Z\<^sub>2 \<Rightarrow> Z\<^sub>2" ("\<^bold>\<sim>") where
  "\<^bold>\<sim>1 = 0" |
  "\<^bold>\<sim>0 = 1" 

(*Let us introduce the following convenient binary operations based upon negation:*)
abbreviation(input) Nmeet (infixl "\<^bold>\<up>" 56) (*aka. Sheffer stroke*)
  where "x \<^bold>\<up> y \<equiv> \<^bold>\<sim>(x \<^bold>\<and> y)"
abbreviation(input) Njoin (infixl "\<^bold>\<down>" 55) (*aka. Peirce arrow or Quine dagger*)
  where "x \<^bold>\<down> y \<equiv> \<^bold>\<sim>(x \<^bold>\<or> y)"

(*Finally, let us obtain convenient polynomial representations of the operators discussed above: *)
lemma "\<^bold>\<sim> = poly1 c\<^sub>1 c\<^sub>0" nitpick[satisfy, eval="poly1 c\<^sub>1 c\<^sub>0"] oops
lemma "(\<^bold>\<up>) = poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" nitpick[satisfy, eval="poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"] oops
lemma "(\<^bold>\<down>) = poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" nitpick[satisfy, eval="poly2 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"] oops

lemma Negation_polydef: "\<^bold>\<sim>x = x + 1" by (metis Addition.simps(2) Addition.simps(4) Negation.cases Negation.simps(1) Negation.simps(2))
lemma Nmeet_polydef: "x \<^bold>\<up> y = x\<cdot>y + 1" by (simp add: Meet_polydef Negation_polydef)
lemma Njoin_polydef: "x \<^bold>\<down> y = x\<cdot>y + x + y + 1" by (simp add: Join_polydef Negation_polydef)


named_theorems polydefs
declare Meet_polydef[polydefs] Join_polydef[polydefs] 
        Implication_polydef[polydefs] DualImplication_polydef[polydefs]
        Negation_polydef[polydefs] Nmeet_polydef[polydefs] Njoin_polydef[polydefs]

end