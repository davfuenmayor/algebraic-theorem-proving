(**************************************************************)
(*           Copyright (c) 2024 David Fuenmayor               *)
(*       MIT License (see LICENSE file for details)           *)
(**************************************************************)
theory F4_orderL
imports F4
begin

fun leqL::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> bool"  (infix "\<le>" 51) where
  "0 \<le> _ = \<top>" |
  "_ \<le> 1 = \<top>" |
  "a \<le> a = \<top>" |
  "b \<le> b = \<top>" |
  "_ \<le> _ = \<bottom>"

abbreviation(input) geqL::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> bool" (infix "\<ge>" 51)
  where "x \<ge> y \<equiv> y \<le> x"


(*Checks*)
lemma reflL: "x \<le> x" by (smt (verit) leqL.simps leqL.elims)
lemma transL: "x \<le> y \<and> y \<le> z \<longrightarrow> x \<le> z" by (smt (verit) leqL.simps leqL.elims)
lemma antisymL: "x \<le> y \<and> y \<le> x \<longrightarrow> x = y" by (smt (verit) leqL.simps leqL.elims)

(*Note that the order is not linear (a and b are incomparable):*)
lemma "a \<le> b" nitpick oops (*countermodel*)
lemma "b \<le> a" nitpick oops (*countermodel*)

(*Let's introduce the L-lattice operations: meet and join*)
fun MeetL::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> F\<^sub>4" (infixl "\<^bold>\<and>" 56) where (* L-lattice meet *)
  "0 \<^bold>\<and> 0 = 0" |
  "0 \<^bold>\<and> 1 = 0" |
  "0 \<^bold>\<and> a = 0" |
  "0 \<^bold>\<and> b = 0" |
  "1 \<^bold>\<and> 0 = 0" |
  "1 \<^bold>\<and> 1 = 1" |
  "1 \<^bold>\<and> a = a" |
  "1 \<^bold>\<and> b = b" |
  "a \<^bold>\<and> 0 = 0" |
  "a \<^bold>\<and> 1 = a" |
  "a \<^bold>\<and> a = a" |
  "a \<^bold>\<and> b = 0" |
  "b \<^bold>\<and> 0 = 0" |
  "b \<^bold>\<and> 1 = b" |
  "b \<^bold>\<and> a = 0" |
  "b \<^bold>\<and> b = b"

fun JoinL::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> F\<^sub>4" (infixl "\<^bold>\<or>" 55) where (* L-lattice join *)
  "0 \<^bold>\<or> 0 = 0" |
  "0 \<^bold>\<or> 1 = 1" |
  "0 \<^bold>\<or> a = a" |
  "0 \<^bold>\<or> b = b" |
  "1 \<^bold>\<or> 0 = 1" |
  "1 \<^bold>\<or> 1 = 1" |
  "1 \<^bold>\<or> a = 1" |
  "1 \<^bold>\<or> b = 1" |
  "a \<^bold>\<or> 0 = a" |
  "a \<^bold>\<or> 1 = 1" |
  "a \<^bold>\<or> a = a" |
  "a \<^bold>\<or> b = 1" |
  "b \<^bold>\<or> 0 = b" |
  "b \<^bold>\<or> 1 = 1" |
  "b \<^bold>\<or> a = 1" |
  "b \<^bold>\<or> b = b" 

lemma latticeL_distr1: "(x \<^bold>\<and> (y \<^bold>\<or> z)) = ((x \<^bold>\<and> y) \<^bold>\<or> (x \<^bold>\<and> z))"
  by (smt (z3) JoinL.simps MeetL.simps F\<^sub>4.exhaust)
lemma latticeL_distr2: "(x \<^bold>\<or> (y \<^bold>\<and> z)) = ((x \<^bold>\<or> y) \<^bold>\<and> (x \<^bold>\<or> z))"
  by (smt (z3) JoinL.simps MeetL.simps F\<^sub>4.exhaust)


subsection \<open>Residuation (wrt. A-lattice)\<close>

(*First, observe that the following don't hold for inequalities: *)
lemma "((x + y) \<le> z) \<longleftrightarrow> (x \<le> (z - y))" nitpick oops (*countermodel: addition can 'overflow' (ring is finite)*)
lemma "y \<noteq> 0 \<Longrightarrow> ((x * y) \<le> z) \<longleftrightarrow> (x \<le> (z / y))" nitpick oops (*countermodel*)


abbreviation residualL ("RESID\<^sup>L") 
  where "RESID\<^sup>L f g \<equiv> \<forall>x y z. (f z x \<le> y) \<longleftrightarrow> (x \<le> g z y)"

(*In fact, left/right residuals, when they exist, are unique*)
lemma "RESID\<^sup>L f g\<^sub>1 \<and> RESID\<^sup>L f g\<^sub>2 \<longrightarrow> g\<^sub>1 = g\<^sub>2" 
  using antisym refl (*by metis*) sorry (*TODO: metis reconstruction fails *)
lemma "RESID\<^sup>L f\<^sub>1 g \<and> RESID\<^sup>L f\<^sub>2 g \<longrightarrow> f\<^sub>1 = f\<^sub>2" 
  using antisym refl (*by metis*) sorry (*TODO: metis reconstruction fails *)

(*As it happens, there is no right residual to '*' and no left residual to '+' either: *)
lemma "RESID\<^sup>L (*) g" nitpick[satisfy, expect=none] oops
lemma "RESID\<^sup>L f (+)" nitpick[satisfy, expect=none] oops

(*But there is (at least) a residuated pair \<langle>f,g\<rangle> to be found... *)
lemma "RESID\<^sup>L f g" nitpick[satisfy] oops

(*In fact, meet-A resp. join-A have right resp left residuals, and we can use nitpick to find them: *)
lemma "RESID\<^sup>L (\<^bold>\<and>) g" nitpick[satisfy] oops
lemma "RESID\<^sup>L f (\<^bold>\<or>)" nitpick[satisfy] oops

(*We call meet's right residual: 'implication'. Based upon the truth table generated by nitpick we define:*)
fun ImplicationL::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> F\<^sub>4" (infixr "\<^bold>\<rightarrow>" 54) where
  "0 \<^bold>\<rightarrow> 0 = 1" | 
  "0 \<^bold>\<rightarrow> 1 = 1" |
  "0 \<^bold>\<rightarrow> a = 1" |
  "0 \<^bold>\<rightarrow> b = 1" |
  "1 \<^bold>\<rightarrow> 0 = 0" |
  "1 \<^bold>\<rightarrow> 1 = 1" |
  "1 \<^bold>\<rightarrow> a = a" |
  "1 \<^bold>\<rightarrow> b = b" |
  "a \<^bold>\<rightarrow> 0 = b" |
  "a \<^bold>\<rightarrow> 1 = 1" |
  "a \<^bold>\<rightarrow> a = 1" |
  "a \<^bold>\<rightarrow> b = b" |
  "b \<^bold>\<rightarrow> 0 = a" |
  "b \<^bold>\<rightarrow> 1 = 1" |
  "b \<^bold>\<rightarrow> a = a" |
  "b \<^bold>\<rightarrow> b = 1"

(*We call joins's left residual: 'dual-implication'. Based upon the truth table generated by nitpick we define:*)
fun DualImplicationL::"F\<^sub>4 \<Rightarrow> F\<^sub>4 \<Rightarrow> F\<^sub>4" (infixl "\<^bold>\<rightharpoonup>" 54) where
  "0 \<^bold>\<rightharpoonup> 0 = 0" |
  "0 \<^bold>\<rightharpoonup> 1 = 1" |
  "0 \<^bold>\<rightharpoonup> a = a" |
  "0 \<^bold>\<rightharpoonup> b = b" |
  "1 \<^bold>\<rightharpoonup> 0 = 0" |
  "1 \<^bold>\<rightharpoonup> 1 = 0" |
  "1 \<^bold>\<rightharpoonup> a = 0" |
  "1 \<^bold>\<rightharpoonup> b = 0" |
  "a \<^bold>\<rightharpoonup> 0 = 0" |
  "a \<^bold>\<rightharpoonup> 1 = b" |
  "a \<^bold>\<rightharpoonup> a = 0" |
  "a \<^bold>\<rightharpoonup> b = b" |
  "b \<^bold>\<rightharpoonup> 0 = 0" |
  "b \<^bold>\<rightharpoonup> 1 = a" |
  "b \<^bold>\<rightharpoonup> a = a" |
  "b \<^bold>\<rightharpoonup> b = 0"

lemma residL_law1: "RESID\<^sup>L (\<^bold>\<and>) (\<^bold>\<rightarrow>)" by (smt (z3) ImplicationL.simps MeetL.simps leqL.simps F\<^sub>4.exhaust)
lemma residL_law2: "RESID\<^sup>L (\<^bold>\<rightharpoonup>) (\<^bold>\<or>)" by (smt (z3) DualImplicationL.simps JoinL.simps leqL.simps F\<^sub>4.exhaust)

(*More explicitly, we have: *)
lemma "(z \<^bold>\<and>  x \<le> y) \<longleftrightarrow> (x \<le> z \<^bold>\<rightarrow> y)" by (simp add: residL_law1)
lemma "(z \<^bold>\<rightharpoonup> x \<le> y) \<longleftrightarrow> (x \<le> z \<^bold>\<or> y)" by (simp add: residL_law2)

(*However, an analog result for equalities does not hold:*)
lemma "(z \<^bold>\<and> x = y) \<longleftrightarrow> (x = z \<^bold>\<rightarrow> y)" nitpick oops (*countermodel*)
lemma "(z \<^bold>\<rightharpoonup> x = y) \<longleftrightarrow> (x = z \<^bold>\<or> y)" nitpick oops (*countermodel*)

(*Let's add for writing convenience: *)
abbreviation(input) ImplL_rev (infixl "\<^bold>\<leftarrow>" 54) 
  where "x \<^bold>\<leftarrow> y \<equiv> y \<^bold>\<rightarrow> x"
abbreviation(input) DImplL_rev (infixr "\<^bold>\<leftharpoonup>" 54) 
  where "x \<^bold>\<leftharpoonup> y \<equiv> y \<^bold>\<rightharpoonup> x" 

(*In fact the following holds: *)
lemma "(x \<^bold>\<rightarrow> y = 1) \<longleftrightarrow> (x \<le> y)"
  by (smt (z3) ImplicationL.simps MultiplicativeInverse.cases leqL.simps)
lemma "(x \<^bold>\<leftharpoonup> y = 0) \<longleftrightarrow> (x \<le> y)" 
  by (smt (z3) DualImplicationL.simps MultiplicativeInverse.cases leqL.simps)

(*While the following does not hold: *)
lemma "(x \<^bold>\<rightarrow> y \<ge> b) \<longleftrightarrow> (x \<le> y)" nitpick oops (*counterexample*)
lemma "(x \<^bold>\<rightarrow> y \<ge> a) \<longleftrightarrow> (x \<le> y)" nitpick oops (*counterexample*)
lemma "(x \<^bold>\<leftharpoonup> y \<le> a) \<longleftrightarrow> (x \<le> y)" nitpick oops (*counterexample*)
lemma "(x \<^bold>\<leftharpoonup> y \<le> b) \<longleftrightarrow> (x \<le> y)" nitpick oops (*counterexample*)

(*The previous results justify introducing the following convenient definitions: *)
abbreviation(input) Top ("\<^bold>\<top>\<^sup>L")    where "\<^bold>\<top>\<^sup>L \<equiv> 1"
abbreviation(input) Bottom ("\<^bold>\<bottom>\<^sup>L") where "\<^bold>\<bottom>\<^sup>L \<equiv> 0"

(*Finally, let's find the polynomial representations for the operations discussed above: *)

(*Uses Nitpick to find polynomial coeficients and to compute the table*)
lemma "(\<^bold>\<and>) = poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" 
(*  nitpick[satisfy, eval="poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"]*) oops
lemma "(\<^bold>\<or>) = poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" 
(*  nitpick[satisfy, eval="poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"]*) oops
lemma "(\<^bold>\<rightarrow>) = poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" 
(* nitpick[satisfy, eval="poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"]*) oops
lemma "(\<^bold>\<leftharpoonup>) = poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0" 
(*  nitpick[satisfy, eval="poly2 c\<^sub>1\<^sub>5 c\<^sub>1\<^sub>4 c\<^sub>1\<^sub>3 c\<^sub>1\<^sub>2 c\<^sub>1\<^sub>1 c\<^sub>1\<^sub>0 c\<^sub>9 c\<^sub>8 c\<^sub>7 c\<^sub>6 c\<^sub>5 c\<^sub>4 c\<^sub>3 c\<^sub>2 c\<^sub>1 c\<^sub>0"]*)  oops

(*Verifies polynomial representation*)
lemma MeetL_polydef:            "(x \<^bold>\<and> y)  = (x\<^sup>2\<cdot>y\<^sup>2 + x\<^sup>2\<cdot>y + x\<cdot>y\<^sup>2)" by (smt (z3) Addition.simps Multiplication.simps MeetL.simps F\<^sub>4.exhaust)
lemma JoinL_polydef:            "(x \<^bold>\<or> y)  = (x\<^sup>2\<cdot>y\<^sup>2 + x\<^sup>2\<cdot>y + x\<cdot>y\<^sup>2 + x + y)" by (smt (z3) Addition.simps Multiplication.simps JoinL.simps F\<^sub>4.exhaust)
lemma ImplicationL_polydef:     "(x \<^bold>\<rightarrow> y) = (x\<^sup>2\<cdot>y\<^sup>2 + x\<^sup>2\<cdot>y + x\<cdot>y\<^sup>2 + x + 1)" by (smt (z3) Addition.simps Multiplication.simps ImplicationL.simps F\<^sub>4.exhaust)
lemma DualImplicationL_polydef: "(x \<^bold>\<leftharpoonup> y) = (x\<^sup>2\<cdot>y\<^sup>2 + x\<^sup>2\<cdot>y + x\<cdot>y\<^sup>2 + x)" by (smt (z3) Addition.simps Multiplication.simps DualImplicationL.simps F\<^sub>4.exhaust)


named_theorems polydefs
declare MeetL_polydef[polydefs] JoinL_polydef[polydefs] 
        ImplicationL_polydef[polydefs] DualImplicationL_polydef[polydefs]

end